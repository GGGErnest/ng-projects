<h2>Introduction</h2>
<section>
  <p>The model-driven approach gives a way of defining a model that later will be bind to UI components in the template
    and keeps track of the changes of the states(values). In addition, it provides direct, explicit access to the
    underlying object model in a synchronous way, and compared with the Template-Driven approach, it's way more robust,
    scalable, reusable, flexible, and gives more control over the model.</p>
</section>

<h2>Model-Driven</h2>

<section>
  <p>The model-driven approach provides a way of defining a model that later will be bind to a form of UI components in
    the template and it will keep track of the changes of the states(values). It provides direct, explicit access to the
    underlying object model in a synchronous way and compared with the Template-Driven approach is way more robust,
    scalable, reusable, flexible, and gives more control over the model.</p>
</section>

<h2>Template-Driven</h2>

<section>
  <p>This method is used to bing specific UI components to Qps without the need of creating a model(Ui2QpGroup) and
    Ui2QpRoot. It relies on directives in the template to manipulate and synchronize the component's state to the Qp
    defined.</p>
</section>

<h2>Choosing an approach</h2>

<section>
  <p>Choosing an approach will always depend on each specific use case, but we've learned that are some conditions that
    when met can help to make the decision. Here are some of them:</p>
  <ul>
    <li>Few UI components to save the state.</li>
    <li>The components have no relation between them.</li>
    <li>The state of the UI components won't need any kind of manipulation.</li>
  </ul>
  <p>If the previous conditions are filled for a use case then probably the Template-Driven is the right approach for
    it, if not, Model-Driven will be probably the best option.</p>
</section>

